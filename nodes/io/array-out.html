<script type="text/javascript">
    RED.nodes.registerType('rp-array-out', {
        category: 'RP Utils',
        color: '#87CEEB',
        defaults: {
            name: { value: "" },
            timeout: { value: 5000 },
            expectedCount: { value: 2, required: true, validate: RED.validators.number() },
            outputPath: { value: "payload" },
            outputPathType: { value: "msg" }
        },
        inputs: 1,
        outputs: 2,
        icon: "font-awesome/fa-sign-out",
        label: function() {
            return this.name || `Array Out (${this.expectedCount} items)`;
        },
        oneditprepare: function() {
            // Set up TypedInput for output path
            $("#node-input-outputPath").typedInput({
                default: 'msg',
                types: ['msg', 'flow', 'global'],
                typeField: "#node-input-outputPathType"
            });
        }
    });
</script>

<script type="text/x-red" data-template-name="rp-array-out">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <hr>
    
    <div class="form-row">
        <label for="node-input-timeout"><i class="fa fa-clock-o"></i> Timeout (ms)</label>
        <input type="number" id="node-input-timeout" min="100" step="100" style="width: 70%;" placeholder="5000">
    </div>
    
    <div class="form-row">
        <label for="node-input-expectedCount"><i class="fa fa-hashtag"></i> Expected Count</label>
        <input type="number" id="node-input-expectedCount" min="1" step="1" style="width: 70%;" placeholder="2" required>
    </div>
    
    <div class="form-row">
        <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
        <input type="text" id="node-input-outputPath" style="width: 70%;">
        <input type="hidden" id="node-input-outputPathType">
    </div>
    
    <div class="form-tips">
        <b>Timeout:</b> Maximum time to wait for all array elements after the first message arrives. If timeout occurs, collected data and missing position info are sent to output 2.<br>
        <b>Expected Count:</b> Number of array elements required before outputting the assembled array.
    </div>
</script>

<script type="text/x-red" data-help-name="rp-array-out">
    <p>Collects messages from multiple rp-array-in nodes and assembles them into an ordered array based on position indices.</p>
    
    <h3>Details</h3>
    <p>This node works as the collection point for multiple rp-array-in nodes. It waits for messages containing array metadata, collects them based on their position indices, and outputs a complete array when all expected elements are received. The node includes timeout protection and performance monitoring.</p>
    
    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Timeout <span class="property-type">number</span></dt>
        <dd>Maximum time in milliseconds to wait for all array elements after the first message arrives. Default: 5000ms. If timeout occurs, collected data and missing position info are sent to output 2.</dd>
        <dt>Expected Count <span class="property-type">number</span></dt>
        <dd>Number of array elements required before outputting the assembled array. Must match the number of rp-array-in nodes connected. Required field, minimum value: 1.</dd>
        <dt>Output to <span class="property-type">string</span></dt>
        <dd>The location where the assembled array will be stored. You can select between <code>msg</code>, <code>flow</code>, or <code>global</code> context. Defaults to <code>msg.payload</code>.</dd>
    </dl>

    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">any</span></dt>
        <dd>Messages from rp-array-in nodes containing array metadata.</dd>
        <dt>meta.arrayPosition <span class="property-type">number</span></dt>
        <dd>The array position index (0, 1, 2...) provided by rp-array-in nodes.</dd>
        <dt>meta.arrayData <span class="property-type">any</span></dt>
        <dd>The actual data to be placed in the array at the specified position.</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>Output 1 - Complete Array <span class="property-type">array</span></dt>
        <dd>The complete assembled array when all expected elements are received: [data0, data1, data2...]</dd>
        <dt>Output 2 - Timeout Data <span class="property-type">object</span></dt>
        <dd>On timeout: collected data array (with nulls for missing) plus metadata about missing positions</dd>
    </dl>

    <h3>Operation Flow</h3>
    <ol>
        <li><strong>First Message:</strong> Starts timeout timer and begins collection</li>
        <li><strong>Collection:</strong> Gathers messages from rp-array-in nodes, validates positions</li>
        <li><strong>Assembly:</strong> Places data at specified array positions based on meta.arrayPosition</li>
        <li><strong>Success:</strong> Outputs assembled array when all expected elements received</li>
        <li><strong>Timeout:</strong> Sends collected data + missing info to output 2</li>
        <li><strong>Reset:</strong> Ready for next collection cycle</li>
    </ol>

    <h3>Examples</h3>
    <ul>
        <li><strong>Basic Array Assembly:</strong> With Expected Count = 3, rp-array-in nodes at positions 0, 1, 2 will produce: <code>["data0", "data1", "data2"]</code></li>
        <li><strong>Image Array:</strong> Three image-in → rp-array-in (positions 0,1,2) → rp-array-out → creates array of image objects for batch processing</li>
        <li><strong>Mixed Data:</strong> Combine different data types from various sources into a single ordered array</li>
    </ul>

    <h3>Node Interactions</h3>
    <p><strong>Requires:</strong> Multiple rp-array-in nodes, each with unique position indices (0, 1, 2...)</p>
    <p><strong>Works with:</strong> Transform nodes that support array inputs (resize, rotate, etc.), rp-array-select for element extraction</p>
    <p><strong>Best Practice:</strong> Set Expected Count to match the number of rp-array-in nodes. Use reasonable timeout values based on your processing requirements.</p>

    <h3>Error Handling</h3>
    <p>The node handles various error conditions:</p>
    <ul>
        <li><strong>Missing metadata:</strong> Messages without proper array metadata are ignored</li>
        <li><strong>Duplicate positions:</strong> Later messages overwrite earlier ones at the same position</li>
        <li><strong>Timeout:</strong> Collection resets, node status shows timeout, no output sent</li>
    </ul>

    <h3>Performance</h3>
    <p>Node status displays collection timing when successful. The timeout mechanism prevents indefinite waiting for missing array elements.</p>
</script>
